#!/usr/bin/env python
# 
# 
# pysos written by Jake Hunsaker <jhunsaker@redhat.com>
# rhevlcbridge library  and get_rhevm_info() written by Wallace Daniel
#
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#    General Public License <gnu.org/licenses/gpl.html> for more details.
#
from __future__ import division
from itertools import groupby
from collections import defaultdict
from rhevlcbridge import *
import os, argparse, textwrap, re, datetime, time, math, tempfile, subprocess, tarfile, string, json, urllib2



# switches
parser = argparse.ArgumentParser(description='Make a sosreport pretty.')
parser.add_argument('target', nargs='+', help='Target directory, aka the sosreport root. Use "/" to run locally')
parser.add_argument('-a', "--all", action="store_true", help='Print all information (RHEV excluded)')
parser.add_argument('-b', "--bios", action="store_true", help='Print BIOS and dmidecode information')
parser.add_argument('-o', "--os", action="store_true", help='Prints OS information')
parser.add_argument('-k', "--kdump", action="store_true", help="Prints kdump information")
parser.add_argument('-c', "--cpu", action="store_true", help='Print CPU information ONLY')
parser.add_argument('-m', "--memory", action="store_true", help='Prints memory information')
parser.add_argument('-d', "--disk", action="store_true", help='Print /proc/partition information')
parser.add_argument('-l', "--lspci", action="store_true", help='Print lspci information')
parser.add_argument('-e', '--ethtool', action="store_true", help='Prints ethtool information')
parser.add_argument('-g', "--bonding", action="store_true", help='Print bonding information')
parser.add_argument('-i', "--ip", action="store_true", help='Print IP information')
parser.add_argument('-n', "--netdev", action="store_true", help='Print proc/net/dev information')
parser.add_argument("--net", action="store_true", help='Alias for --ethtool, --bonding, --ip, --netdev')
parser.add_argument('-s', "--sysctl", action="store_true", help='Print all sysctl information')
parser.add_argument('-p', "--ps", action="store_true", help='Print ps information')
parser.add_argument("--check", help='Check package for known bugs')

parser.add_argument('-t', "--test", action="store_true")

parser.add_argument('-r', "--rhev", action="store_true", help='Print RHEV Information')
parser.add_argument("--db", action="store_true", help = 'Print RHEV DB information')


args = parser.parse_args()

# Define colors - yay color!
# Need more - build out later
class colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    SECTION = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    WHITE = '\033[1;37m'
    GREY = '\033[37m'
    HEADER_BOLD = '\033[95m' + '\033[1m'
    WARN = '\033[33m'
    PURPLE = '\033[35m'
    CYAN = '\033[36m'
    DBLUE = '\033[34m'
    
def find_rpm(target, rpm, local=False):
	# from here we will pull specific targets for installed RPMS
	rpm_state = False
	if local:
		temp_file = tempfile.NamedTemporaryFile(delete=False)
		command = subprocess.Popen(['rpm', '-qa', rpm], stdout=subprocess.PIPE)
		output = command.stdout.read()
		for line in output:
			temp_file.write(line)
		temp_file.close()
		rpm_file = temp_file.name

		
	else:
		rpm_file = target + 'installed-rpms'
			
	if os.path.isfile(rpm_file):
		with open(rpm_file, 'r') as rpmfile:
			for line in rpmfile:
				if line.startswith(rpm):
					rpm_state = line.split()[0]
					return rpm_state
		if not rpm_state:
			return 'not installed'
	else:
		return 'installed-rpms not found'
	
	try:
		os.remove(temp_file.name)
	except:
		pass	

def check_installed(target, rpm):
	print colors.SECTION + 'Package Check' + colors.ENDC
	print ''
	
	if rpm == 'all':
		with open(target + 'installed-rpms', 'r') as rfile:
			for line in rfile:
				ver = line.split()[0]
				package = check_rpm_ver(ver, all_test=True)
				if package:
					print '\t' + colors.RED + colors.BOLD +' {:10} : '.format(ver) + colors.ENDC +' {:20}'.format(package[0]) \
					+ colors.WHITE + '  KCS :' + colors.ENDC +' {:7}'.format(package[1]) + colors.WHITE + '  BZ :' + colors.ENDC \
					+' {:7}'.format(package[2])
	else:
		with open(target + 'installed-rpms', 'r') as rfile:
			for line in rfile:
				if rpm in line:
					ver = line.split()[0]
					package = check_rpm_ver(ver, stand_alone=True)
					if type(package) is list:
						print '\t' + colors.RED + colors.BOLD +'{:10} : '.format(ver) + colors.ENDC +' {:20}'.format(package[0]) \
					+ colors.WHITE + '  KCS :' + colors.ENDC +' {:7}'.format(package[1]) + colors.WHITE + '  BZ :' + colors.ENDC \
					+' {:7}'.format(package[2])
					else:
						print '\t' + colors.BLUE + ver + colors.ENDC + ' : %s' % package
		
def check_rpm_ver(rpm, stand_alone=False, all_test=False):
	index = rpm.find('.')
	index2 = rpm.find('.el6')
	rpmname = rpm[0:index-2]
	version = rpm[index-1:index2]
	base_url = "http://pysosweb-wdaniel.itos.redhat.com/"
	check_url = base_url + 'check/' + rpmname + '/' + version

	try:
		rpm_check = urllib2.urlopen(check_url)
	except:
		if stand_alone:
			return 'Cannot query pysosweb'
		else:		
			return False
	data = json.load(rpm_check)
	status = data['status']
	if stand_alone:
				
		if status == 'success':
			bz = data['bz']
			kcs = data['kcs']
			warning = data['warning']
			return [warning, kcs, bz]
		elif 'fail' in status:
			return 'No entries found'
		else:
			return 'Invalid RPM'
	elif all_test:
		if status == 'success':
			bz = data['bz']
			kcs = data['kcs']
			warning = data['warning']
			return [warning, kcs, bz]
		else:
			return False	
	else:
		if status == 'success':
			bz = data['bz']
			kcs = data['kcs']
			warning = data['warning']
			return [warning, kcs, bz]
		else:
			return False
		
def find_chkconfig(target, service):
	
	# search for specific config states for a given service
	service_status = False
	if not os.path.isfile(target + 'chkconfig'):
		service_status = colors.WARN + colors.BOLD + 'chkconfig file not found!' + colors.ENDC
		return service_status
	with open(target + 'chkconfig', 'r') as configfile:
		for line in configfile:
			if service in line:
				service_status = line.rstrip('\n')
				return service_status
				
	if not service_status:
		service_status = colors.WARN + '%s not found in chkconfig' %service
		return service_status
	
def get_status(target, status, local=False):


	if not local:
		statuses = {}
		statuses['hostname'] = 'sos_commands/general/hostname'
		statuses['release'] = 'etc/redhat-release'
		statuses['runlevel'] = 'sos_commands/startup/runlevel'
		statuses['uptime'] = 'sos_commands/general/uptime'
		statuses['kernel'] = "sos_commands/kernel/uname_-a"
		statuses['cmdline'] = 'proc/cmdline'
		statuses['date'] = 'date'
	else:
		statuses = {}
		stats = {}
		statuses['release'] = 'etc/redhat-release'
		statuses['cmdline'] = 'proc/cmdline'
		statuses['kernel'] = 'proc/version'
		for stat in statuses:
			if os.path.isfile(target + statuses[stat]):
				with open(target + statuses[stat], 'r') as rfile:
					for line in rfile:
						statuses[stat] = line.rstrip('\n')
			else:
				statuses[stat] = 'not hound!'
		for item in ['runlevel', 'uptime', 'date', 'hostname']:
			process = subprocess.Popen(item, stdout=subprocess.PIPE)
			stdout, stderr = process.communicate()
			stats[item] = stdout.rstrip('\n')
		
		try:
			for item in stats:
				statuses[item] = stats[item]
		except:	
			pass
	# get evreything shoved into the statuses dictionary
	if status == 'all':
		for key, path in statuses.items():
			fullpath = '%s%s' %(target, path)
			if os.path.isfile(fullpath):
				with open(fullpath, 'r') as rfile:
					for line in rfile:
						result = line.rstrip('\n')
						statuses[key] = result
			else:
				statuses[key] =  colors.RED  + path + ' not found!' + colors.ENDC


		return statuses
	else:
		if not local:
			if os.path.isfile(target + statuses[status]):
				with open(target + statuses[status], 'r') as rfile:
					for line in rfile:
						statuses[status] = line.rstrip('\n')
						return line.rstrip('\n')
			else:
				return 'not found!'
		else:
			return statuses[status]
def taint_check(target):
	
	# check for kernel taint, well known values go in this dictionary
	t={}
	t['0']="Not tainted. Hooray!"
	t['1']="Proprietary module has been loaded"
	t['2']="Module has been forcibly loaded"
	t['4']="SMP with CPUs not designed for SMP"
	t['8']="User forced a module unload"
	t['16']="System experienced a machine check exception"
	t['32']="System has hit bad_page"
	t['64']="Userspace-defined naughtiness"
	t['128']="Kernel has oopsed before"
	t['256']="ACPI table overridden"
	t['512']="Taint on warning"
	t['1024']="Modules from drivers/staging are loaded"
	t['2048']="Working around severe firmware bug"
	t['4096']="Out-of-tree module has been loaded"
	t['268435456']="Hardware is unsupported"
	t['536870912']="Technology Preview code is loaded"
	
	# add logic for stacked codes later
	with open(target + 'proc/sys/kernel/tainted', 'r') as tfile:
		check = tfile.read().splitlines()
		if check[0] in t:
			return t[check[0]]
		else:
			return 'Undefined taint code : %s' %check[0]
			
			
def get_rhn(target, local):
	if os.path.isfile(target + 'etc/sysconfig/rhn/up2date'):
		with open(target + 'etc/sysconfig/rhn/up2date', 'r') as rhnfile:
			for line in rhnfile:
				if re.match('^serverURL=.*', line):
					return line.rstrip('\n')
	else:
		return colors.WARN + 'Up2date file not found' + colors.ENDC
		
def sel_check(target):
	# checking for how SELinux starts
	if os.path.isfile(target + 'etc/selinux/config'):
		with open(target + 'etc/selinux/config', 'r') as selfile:
			for line in selfile:
				if re.match("SELINUX=", line):
					index = line.find("=")
					selstate = line[index+1:len(line)].rstrip('\n')
					return selstate
			if not selstate:
				selstate = colors.WARN + 'SELinux state unknown' + colors.ENDC
				return selstate
	else:
		return 'Unknown. etc/selinux/config file not found'
			
def get_loadavg(target, cpus, local):
	
	if local:
		mem_file = tempfile.NamedTemporaryFile(delete=False)
		command = subprocess.Popen('uptime', stdout=subprocess.PIPE)
		output = command.stdout.read()
		for line in output:
			mem_file.write(line)
		mem_file.close()
		load_file = mem_file.name
	else:
		load_file = target + 'uptime'
	# get raw loadavg report from sosreport
	with open(load_file, 'r') as lfile:
		load = lfile.readline()
		index = load.find('e:')
		loadavg = load[index+2:len(load)].rstrip('\n')
		
	# now, calculate percent load from the string
	loads = loadavg.split(',')
	for item in loads:
		index = loads.index(item)
		loadperc = (float(item) / cpus) * 100
		loads[index] = (loads[index] + colors.DBLUE + '(%.2f%%)' + colors.ENDC) %loadperc
	return str(loads[0] + loads[1] + loads[2])
	
	try:
		os.remove(mem_file.name)
	except:
		pass	
def graphit(perc):
	
	# general graphing function, needs to be fed a percentage. 
	tick = u"\u25C6"
	empty = u"\u25C7"	
	filled = round(40 * (perc / 100))
	nofill = 40 - filled
	percf = '%.2f' %perc + ' %'
	graph = tick * int(filled) + empty * int(nofill) + '  %7s' %percf
	return graph
	
def get_os_info(target, local): 
	
	rhnserver = get_rhn(target, local)
	tainted = taint_check(target)		
	selstate = sel_check(target)
	
	# load info from proc/stat - may separate this out later.
	with open(target + 'proc/stat', 'r') as statfile:
		num_cpus = -1  # to account for "cpu" on line 1, then leading into "cpuX"
		for line in statfile:
			if re.match("btime", line):
				btime = line.split(" ")[1]
				boottime = datetime.datetime.fromtimestamp(int(btime)).strftime('%a %b %d %H:%M:%S'\
				 + colors.WHITE + colors.BOLD + ' UTC ' + colors.ENDC + '%Y')
			if re.match("^cpu", line):
				num_cpus += 1
			if re.match("processes", line):
				num_procs = line.split(" ")[1].rstrip('\n')
			if re.match("procs_running", line):
				run_procs = line.split(" ")[1].rstrip('\n')
		if not boottime:
			boottime = colors.RED + 'Could not find boot time' + colors.ENDC
	

	loadavg = get_loadavg(target, num_cpus, local)	
	sys = get_status(target, 'date', local)			
	# from sys time and boot time calc uptime rather than butcher the uptime string more
	if boottime and btime and ('not found' not in sys):         
		# Python strptime only works for timezone the 
		index = sys.find(sys.split()[-2])	# local computer is set to, so we need to strip the TZ
		systime = str(sys[0:index] + sys[index+3:len(sys)])
		systimesec = time.mktime(datetime.datetime.strptime(systime, "%a %b  %d %H:%M:%S %Y").timetuple())		
		uptime = str(datetime.timedelta(seconds=(int(systimesec) - int(btime))))
	else:
		uptime = colors.RED + colors.BOLD + 'Cannot determine uptime' + colors.ENDC

	# Print it all pretty like.
	print colors.SECTION + colors.BOLD + "OS " + colors.ENDC
	print colors.HEADER_BOLD + '\t Hostname  : ' + colors.ENDC + get_status(target, 'hostname', local)
	print colors.HEADER_BOLD +  '\t Release   : ' + colors.ENDC + get_status(target, 'release', local)
	print colors.HEADER_BOLD + '\t RHN Info  : ' + colors.ENDC + rhnserver
	print colors.HEADER_BOLD + '\t Runlevel  : ' + colors.ENDC + get_status(target, 'runlevel', local)
	print colors.HEADER_BOLD +  '\t SELinux   : ' + colors.ENDC + selstate
	
	print colors.HEADER_BOLD + '\t Kernel    : ' + colors.ENDC
	print '\t   ' + colors.BLUE + colors.BOLD + 'Booted kernel  : ' + colors.ENDC + str(get_status(target, 'kernel', local)).split(" ")[2]
	print '\t   ' + colors.BLUE + colors.BOLD + 'GRUB default   : '
	print '\t   ' + colors.BLUE + colors.BOLD + 'Booted cmdline : ' + colors.ENDC
	print '%15s' % ' ' + textwrap.fill(get_status(target, 'cmdline', local), 90, subsequent_indent='%15s' % ' ')
	print '\t   ' + colors.BLUE + colors.BOLD + 'Taint-check    : ' + colors.ENDC + str(tainted)
	
	print colors.GREEN + '%9s' % ' ' + colors.BOLD + '~ ' * 20 + colors.ENDC
	
	print colors.HEADER_BOLD  + '\t Boot time : ' + colors.ENDC + boottime
	print colors.HEADER_BOLD  + '\t Sys time  : ' + colors.ENDC + sys
	print colors.HEADER_BOLD + '\t Uptime    : ' + colors.ENDC + uptime
	print colors.HEADER_BOLD + '\t Load Avg  : ' + colors.WHITE +'[%s CPUs] ' %(num_cpus) + colors.ENDC \
	 + loadavg
	print colors.HEADER_BOLD + '\t /proc/stat: ' + colors.ENDC
	print '\t   ' + colors.BLUE + colors.BOLD + 'procs_running : ' + colors.ENDC + run_procs + colors.BLUE + colors.BOLD + '   processes (since boot) : ' + colors.ENDC + num_procs

def check_mem(target, scope):				
	# check proc/meminfo for mem-related stats.
	# if scope is 'all', grab everything we care about at once
	if scope == 'all':
		if os.path.isfile(target + 'proc/meminfo'):
			with open(target + 'proc/meminfo', 'r') as meminfo:
				for line in meminfo:
					if 'MemTotal' in line:
						total_mem = round((int(line.split()[1]) / 1024), 2)
					if 'MemFree' in line:
						free_mem = round((int(line.split()[1]) / 1024), 2)
					if 'Buffers' in line:
						buffered_mem = round((int(line.split()[1]) / 1024), 2)
					if re.match ('^Cached:', line):
						cached_mem = round((int(line.split()[1]) / 1024), 2)
						cached_perc = (cached_mem / total_mem) * 100
					if 'HugePages_Total:' in line:
						hugepages = round(int(line.split()[1]) / 1024, 2)
						hugepage_perc = (hugepages / total_mem) * 100
					if 'Dirty:' in line:
						dirty_mem = round((int(line.split()[1]) / 1024), 2)
						dirty_perc = (dirty_mem / total_mem) * 100
					if 'Slab:' in line:
						slab = round((int(line.split()[1]) / 1024), 2)
						slab_perc = (slab / total_mem) * 100
					if 'SwapTotal:' in line:
						swap_total = round((int(line.split()[1]) / 1024), 2)
					if 'SwapFree:' in line:
						swap_free = round(int(line.split()[1]) / 1024, 2)
			if total_mem and free_mem:
				used_mem = round((total_mem - free_mem), 2)	
				perc_used = round(((used_mem / total_mem) * 100), 2)
			if swap_total and swap_free:
				swap_used = swap_total - swap_free
				swap_perc = (swap_used / swap_total) * 100
			else:
				swap_used = 0
				swap_perc = 0	
			try:
				hugepages
			except:
				hugepages = 0
				hugepage_perc = 0
			return used_mem, free_mem, total_mem, perc_used, hugepages, hugepage_perc,\
			dirty_mem, dirty_perc, slab, slab_perc, swap_total, swap_free, swap_used, swap_perc,\
			buffered_mem, cached_perc, cached_mem
	else:
		# need to build out selective mem check, if needed
		pass
		
def get_mem_info(target):
	
	# get all of our mem stats from check_mem
	used_mem, free_mem, total_mem, perc_used, hugepages, hugepage_perc, dirty_mem,\
	dirty_perc, slab, slab_perc, swap_total, swap_free, swap_used,\
	swap_perc, buffered_mem, cached_perc, cached_mem  = check_mem(target, 'all')
		
	# generate graphs for memory related stuff	
	usedgraph = graphit(perc_used)
	hugepagegraph = graphit(hugepage_perc)
	slabgraph = graphit(slab_perc)
	dirtygraph = graphit(dirty_perc)
	slabgraph = graphit(slab_perc)
	swapgraph = graphit(swap_perc)
	buffergraph = graphit(((buffered_mem / total_mem) * 100))
	cachedgraph = graphit(cached_perc)
	
	# print this all pretty
	print colors.SECTION + colors.BOLD + "Memory " + colors.ENDC
	print colors.HEADER + colors.BOLD + '\t Memory Statistics graphed : ' + colors.ENDC
	print colors.BLUE + '\t\t Used      : %8.2f GB ' %(used_mem / 1024) + usedgraph + colors.ENDC 
	print colors.PURPLE + '\t\t Buffered  : %8.2f GB ' %(buffered_mem / 1024) + buffergraph + colors.ENDC
	print colors.CYAN + '\t\t Cached    : %8.2f GB ' %(cached_mem / 1024) + cachedgraph + colors.ENDC
	print colors.GREEN + '\t\t Hugepages : %8s MB ' %hugepages + hugepagegraph + colors.ENDC
	print colors.RED + '\t\t Dirty     : %8s MB ' %dirty_mem + dirtygraph + colors.ENDC
	print colors.WHITE + '\t\t SLAB      : %8s MB ' %slab + slabgraph + colors.ENDC

	print colors.HEADER + colors.BOLD + '\t RAM  :' + colors.ENDC
	print '\t\t %6.2f GB total RAM on system' %(int(total_mem) / 1024)
	print colors.BLUE  + '\t\t %6.2f GB (%.2f %%) used' %((used_mem / 1024), perc_used) + colors.ENDC
	print colors.PURPLE + '\t\t %6.2f GB (%.2f %%) buffered' %((buffered_mem / 1024), ((buffered_mem / total_mem) * 100)) + colors.ENDC
	print colors.CYAN + '\t\t %6.2f GB (%.2f %%) cached' %((cached_mem / 1024), cached_perc) + colors.ENDC
	print colors.RED + '\t\t %6.2f MB (%.2f %%) dirty' %(dirty_mem, dirty_perc) + colors.ENDC
	
	print colors.HEADER + colors.BOLD + '\t Misc :'+ colors.ENDC
	print '\t\t %6s MB (%.2f %%) of total RAM used for SLAB' %(slab, slab_perc)
	print '\t\t %6s MB (%.2f %%) of total RAM used for Hugepages' %(hugepages, hugepage_perc)
	
	
	print colors.HEADER + colors.BOLD + '\t Swap :' + colors.ENDC
	print '\t\t %6s MB (%.2f %%) swap space used' %(swap_used, swap_perc)


def check_initrd(target):
	initrd = colors.WARN + 'initrd.img not found in sos_commands/bootloader/ls_-laR_.boot' + colors.ENDC
	if not os.path.isfile(target + 'sos_commands/bootloader/ls_-laR_.boot'):
		initrd = colors.WARN + 'missing ' + target +'sos_commands/bootloader/ls_-laR_.boot' + colors.ENDC
		return str(initrd)
		
	with open(target + 'sos_commands/bootloader/ls_-laR_.boot') as kfile:
		for line in kfile:
			if 'initrd' in line:
				initrd = line.split()[-1]
				return initrd
	return initrd
	
def get_kernel_info(target, local):
	
	# get kexec version, service enablement, initrd.img, kdump path
	kexec_ver = find_rpm(target, 'kexec-tools', local)
	kdump_status = find_chkconfig(target, 'kdump')
	initrd = check_initrd(target)
	
	# cmdline setting for crashkernel
	cmdline = get_status(target, 'cmdline')
	if 'crashkernel' in cmdline:
		index = cmdline.find('crashkernel')
		state = cmdline[index:-1].split()[0]
	else:
		state = colors.WARN + 'crashkernel setting not configured' + colors.ENDC	
		
	# parse kdump.conf for settings, then extrapolate others (more to come)
	config = []
	if os.path.isfile(target + 'etc/kdump.conf'):
		with open(target + 'etc/kdump.conf', 'r') as kfile:
			for line in kfile:
				if not line.startswith("#") and not line.startswith('\n'):
						config.append(line.rstrip('\n'))
	
		# set these to default of the / filesystem.
		filesys = '/'
		mount_at = '/'
		size = int(0)
		for item in config:
			if 'path' in item:
				crashpath = item.split()[1]
				index = crashpath.find('/')
				filesys = crashpath[index:len(crashpath)]
				mount_at = "/"
			with open(target + 'df', 'r') as df:
				for line in df:
					if len(line.split()) == 4:
						if line.split()[4] == mount_at:	
							size = round((int(line.split()[0]) / 1048576), 0)
							#mount_at = '%s' %filesys
							break
					elif len(line.split()) == 6:
						if line.split()[5] == mount_at:	
							size = round((int(line.split()[1]) / 1048576), 0)
							#mount_at = '%s' %filesys
							break	

	else:
		config.append(str(colors.WARN + 'kdump.conf not found' + colors.ENDC))
		mount_at = colors.WARN + 'Unknown' + colors.ENDC
		size = colors.WARN + 'Unknown' + colors.ENDC
	
	# find all panic related sysctl's, and split it up when we go to print it
	
	panic_ctl = find_sysctl(target, 'panic')	
						
	print colors.SECTION + colors.BOLD + 'Kdump ' + colors.ENDC
	print colors.HEADER_BOLD + '\t kexec-tools version :  ' + colors.ENDC + kexec_ver
	print colors.HEADER_BOLD + '\t Service enablement  :  ' + colors.ENDC + kdump_status
	print colors.HEADER_BOLD + '\t kdump initrd.img    :  ' + colors.ENDC + initrd
	print colors.HEADER_BOLD + '\t Memory Reservation  :  ' + colors.ENDC
	print colors.BLUE + colors.BOLD + '\t\t kernel arg   : ' + colors.ENDC + state
	print colors.BLUE + colors.BOLD + '\t\t GRUB conf    : ' + colors.ENDC
	print colors.HEADER_BOLD + '\t kdump.conf          : ' + colors.ENDC
	for item in config:
		print '\t\t\t        %s' %item
	print colors.BLUE + colors.BOLD + '\t\t path mount   : ' + colors.ENDC + mount_at
	print colors.BLUE + colors.BOLD + '\t\t avail space  :' + colors.ENDC + ' %.0f GB' %size		
	print colors.HEADER_BOLD + '\t Kernel Panic sysctl : ' + colors.ENDC
	for item in panic_ctl:
		kern = colors.BLUE + colors.BOLD + item.split()[0] + colors.ENDC
		if item.split()[2] == '0':
			ctl = ' = 0 ' + '[disabled]' + colors.ENDC
		elif item.split()[2] == '1':
			ctl = ' = 1 ' + colors.BOLD + '[enabled]' + colors.ENDC
		else:
			ctl = ' = %s ' %item.split()[2]
		print '\t\t\t\t {:<31} {}'.format(item.split()[0], ctl)

def get_cpu_info(target):
	if os.path.isfile(target + 'proc/cpuinfo'):
		processors = int()
		phys_cpus = int()
		core_count = int()
		threads = int()	
		with open(target + 'proc/cpuinfo', 'r') as cfile:
			for line in cfile:
				index = line.find(':')
				if line.startswith('processor'):
					processors += 1
				if 'model name' in line:
					cpu_model = line[index+2:len(line)].rstrip('\n')
				if line.startswith('physical'):
					phys_cpus = (int(line[index+2:len(line)].rstrip('\n')) + 1)
				if re.match('^cpu cores', line):
					core_count = line[index+2:len(line)].rstrip('\n')
				if line.startswith('siblings'):
					threads = line[index+2:len(line)].rstrip('\n')
				if line.startswith('flags'):
					cpu_flags = line[index+2:len(line)].rstrip('\n')
			if 'QEMU' in cpu_model:
				phys_cpus = '0 [virt] '
				core_count = processors
				threads = 1
		print colors.SECTION + colors.BOLD + 'CPU' + colors.ENDC
		print colors.WHITE + colors.BOLD + '\t\t %s logical processors' %processors + colors.ENDC
		print '\t\t %s %s processors' %(phys_cpus, cpu_model)
		print '\t\t %s cores / %s threads per physical processor' %(core_count, threads)
		print '\t\t flags : ' + textwrap.fill(cpu_flags, 80, subsequent_indent='%25s' % ' ')
	else:
		print 'Error parsing proc/cpuinfo'


def get_bios_info(target, local):
	total_cores = 0
	total_threads = 0
	cpus_populated = 0
	mem_arrays = 0
	fam_count = 0
	ver_count = 0
	total_mem = 0
	dimm_count = 0
	empty_dimms = 0
	core_count = 0
	thread_count = 0
	if local:
		temp_file = tempfile.NamedTemporaryFile(delete=False)
		command = subprocess.Popen(['dmidecode'], stdout=subprocess.PIPE)
		output = command.stdout.read()
		for line in output:
			temp_file.write(line)
		temp_file.close()
		dmi_file = temp_file.name
	else:
		dmi_file = target + 'dmidecode'
	
	if os.path.isfile(dmi_file):
		with open(dmi_file, 'r') as dfile:
			# first the main iterables that have distinct leading names
			for line in dfile:
				if 'Vendor:' in line:
					bios_vendor = line.split()[1]
				if 'Release Date:' in line:
					bios_date = line.split()[2]
				if 'Thread Count:' in line:
					total_threads += int(line.split()[2])
					thread_count = line.split()[2]
				if 'Core Count:' in line:
					total_cores += int(line.split()[2])
					core_count = line.split()[2]
				if 'Maximum Capacity:' in line:
					index = line.find(':')
					max_mem = line[index+1:len(line)].strip()
				if 'Number Of Devices:' in line:
					dimm_count += int(line.split()[3])
				if re.match('\tSize:', line):
					if 'No Module Installed' in line:
						empty_dimms += 1
					else:
						size = int(line.split()[1])
						total_mem += size
				if 'Status: Populated' in line:
					cpus_populated += 1
				if 'Current Speed' in line:
					cpu_freq = line.split()[2]
				if 'Physical Memory Array' in line:
					mem_arrays +=  1
				if 'Product Name:' in line:
					index = line.find(':')
					server_type = line[index+1:len(line)].rstrip('\n')
				if 'UUID:' in line:
					serv_uuid = line.split()[1]
			# now, some ugly voodoo to get items that have the same leading header
				if 'Family:' in line:
					if fam_count == 0:
						fam_count += 1
					else:
						cpu_family = line.split()[1]
						
						
			# this. this right here is horrible. I'm bad and I should feel bad.
			# ...and also I'm lazy.
				if 'Version:' in line and 'Specification Version:' not in line:
					if ver_count == 0:
						bios_ver = line.split()[1]
						ver_count +=  1
					elif ver_count == 1:
						sys_ver = line.split()[1]
						ver_count += 1
					elif ver_count == 2:
						chas_ver = line.split()[1]
						ver_count += 1
					else:
						index = line.find(':')
						cpu_ver = line[index+1:len(line)].strip()
						
						
		mem_max_format = int((int(max_mem.split()[0]) * mem_arrays))
		if mem_max_format >= 1024:
			mem_max_format = str((mem_max_format / 1024)) + ' TB'
		else:
			mem_max_format = str(mem_max_format) + ' GB'				
		print colors.SECTION + 'DMI Decode' + colors.ENDC
		print '\t' + colors.HEADER_BOLD + 'BIOS' + colors.ENDC
		print '\t\t' + colors.BLUE + 'Vendor  : ' + colors.ENDC + bios_vendor
		print '\t\t' + colors.BLUE + 'Version : ' + colors.ENDC + bios_ver
		print '\t\t' + colors.BLUE + 'Release : ' + colors.ENDC + bios_date
		print '\t' + colors.HEADER_BOLD + 'System' + colors.ENDC
		print '\t\t' + colors.BLUE + 'Vendor  : ' + colors.ENDC + bios_vendor
		print '\t\t' + colors.BLUE + 'Server  :' + colors.ENDC + server_type
		print '\t\t' + colors.BLUE + 'UUID    : ' + colors.ENDC + serv_uuid
		print '\t' + colors.HEADER_BOLD + 'CPU' + colors.ENDC
		print '\t\t' + colors.WHITE + '{} CPU sockets populated, {} cores / {} threads per core'.format(cpus_populated, core_count, thread_count) + colors.ENDC
		print '\t\t' + colors.WHITE + '{} total cores - {} total threads'.format(total_cores, total_threads) + colors.ENDC
		print '\t\t' + colors.BLUE + 'Family  : ' + colors.ENDC + cpu_family
		print '\t\t' + colors.BLUE + 'Clock   : ' + colors.ENDC + cpu_freq 
		print '\t\t' + colors.BLUE + 'Model   : ' + colors.ENDC + cpu_ver
		print '\t' + colors.HEADER_BOLD + 'Memory' + colors.ENDC
		print '\t\t' + colors.WHITE + '{} of {} DIMMs populated'.format((dimm_count - empty_dimms), dimm_count) + colors.ENDC
		print '\t\t' + colors.BLUE + 'Total   : ' + colors.ENDC + str(total_mem) + ' MB' + '  ({} GB)'.format((total_mem / 1024))
		print '\t\t' + colors.BLUE + 'Max Mem : ' + colors.ENDC + mem_max_format
		print '\t\t' + colors.GREEN + '{} total memory controllers, {} maximum per controller'.format(mem_arrays, max_mem) + colors.ENDC 			
		
	else:
		print colors.SECTION + 'DMI Decode' + colors.ENDC
		print '\t' + colors.WARN + 'DMIDECODE INFORMATION NOT AVAILABLE' + colors.ENDC
	
	try:
		os.remove(temp_file.name)
	except:
		pass	
				
def find_sysctl(target, sysctl):
	sysctls = []
	if os.path.isfile(target +'sos_commands/kernel/sysctl_-a'):
		with open(target + 'sos_commands/kernel/sysctl_-a', 'r') as sysfile:
			for line in sysfile:
				if sysctl in line:
					sysctls.append(line.rstrip('\n'))
	return sysctls
	
def get_sysctl_info(target):
	
	vm_sysctls = find_sysctl(target, 'vm.')
	vm_prints = ['dirty', 'hugepage', 'panic', 'overcommit', 'swappiness']
	
	net_sysctls = find_sysctl(target, 'net.')
	net_prints = ['core.netdev_budget', 'core.netdev_max_backlog', 'ipv4.tcp_mem', 'ipv4.ip_forward', 'ipv4.icmp_echo_ignore_all',\
	 'ipv4.tcp_rmem', 'ipv4.tcp_wmem', 'ipv4.tcp_max_orphans']
	
	kernel_sysctls = find_sysctl(target, 'kernel.')
	kernel_prints = ['tainted', 'panic', 'pid_max', 'threads-max', 'shmall', 'shmmax', 'shmmni']
	
	print colors.SECTION + colors.BOLD + 'Sysctls' + colors.ENDC
	
	for section in (['kernel', kernel_sysctls, kernel_prints], ['net', net_sysctls, net_prints]\
	, ['vm', vm_sysctls, vm_prints]):
		print colors.HEADER_BOLD + '\t %s' %section[0] + colors.ENDC
		
		for item in section[1]:
			for each in section[2]:
				if each in item:
					item = str(item)
					indexname = item.find('.')
					index = item.find('=')
					print colors.BLUE + colors.BOLD + '\t %33s' %item[indexname+1:index-1] + colors.ENDC + ' = ' + item[index+1:len(item)]


def get_lspci_info(target, local):
	devices = defaultdict(list)
	counter = 0
	if local:
		temp_file = tempfile.NamedTemporaryFile(delete=False)
		command = subprocess.Popen(['lspci'], stdout=subprocess.PIPE)
		output = command.stdout.read()
		for line in output:
			temp_file.write(line)
		temp_file.close()
		lspci_file = temp_file.name
	else:
		lspci_file = target + 'lspci'
		
	if os.path.isfile(lspci_file):
		with open(lspci_file, 'r') as lfile:
			for line in lfile:
				line = line.strip('\n')
				# stop once we go beyond the basic output
				if 'lspci -nvv:' in line:
					break
				if 'lspci:' not in line:
					# don't include the base chipset
					if '00:01' not in line:
						try:
							pci_addr = line.split()[0]
							index = pci_addr.find('.')
							pci_addr = pci_addr[0:index]
							index = line.find(': ')
							dev = line[index+1:len(line)]
							index2 = line.find('.')
							controller = line[index2+2:index]
							if devices.has_key(pci_addr):
								counter += 1
								dev_list = [controller, dev, counter]
								devices[pci_addr] = dev_list
							else:
								counter = 1
								dev_list = [controller, dev, counter]
								devices[pci_addr] = dev_list	
						except:
							pass
					else:
						pass
				else:
					pass
	try:
		os.remove(temp_file.name)
	except:
		pass
		
	print colors.SECTION + 'LSPCI' + colors.ENDC
	print ''
	print colors.HEADER_BOLD + '\t Physical Devices' + colors.ENDC
	linecolor = colors.BLUE + '\t\t'
	for item in sorted(devices):
		value = devices[item]
		# only display hardware devices we care about. Can expand this as we need to
		show_these = ['VGA', 'Ethernet', 'Network', 'Realtek', 'SCSI']
		for item in show_these:
			if item in value[0]:
				print linecolor +  '{:<10} '.format(value[0].split()[0]) + colors.WHITE + '{:^1} ports '.format(value[2]) + colors.ENDC + value[1]


def get_ip_info(target, local=False):
	interfaces = {}
	int_info = defaultdict(list)
	if local:
		mem_file = tempfile.NamedTemporaryFile(delete=False)
		command = subprocess.Popen(['ip', '-o', 'addr'], stdout=subprocess.PIPE)
		output = command.stdout.read()
		for line in output:
			mem_file.write(line)
		mem_file.close()
		ip_file = mem_file.name
		
		temp_file = tempfile.NamedTemporaryFile(delete=False)
		command = subprocess.Popen(['brctl', 'show'], stdout=subprocess.PIPE)
		output = command.stdout.read()
		for line in output:
			temp_file.write(line)
		temp_file.close()
		br_file = temp_file.name
	else:
		ip_file = target + 'ip_addr'
		br_file = target + 'sos_commands/networking/brctl_show'
	
	# get bridge associations
	if os.path.isfile(br_file):
		brfile = True
		with open(br_file, 'r') as bfile:
			bridge_list = list()
			bridges = {}
			bridge_output = bfile.read()
			
			# KNOWN ISSUE:
			# With the below regex, if the bridge only has a single interface on it
			# it will not be captured
			for bridge_lines in re.findall(r'(?m)^\S.*\n(?:\t*\n)+', bridge_output):
				bridge, _ = bridge_lines.split(None, 1)
				bridges[bridge] = re.findall(r'(?m)\S+$', str(bridge_lines))
				bridge_list.append(bridge)
	else:
		brfile = False
	
	if os.path.isfile(ip_file):
		ipfile = True
		with open(ip_file, 'r') as f:
		    lines = [line for line in f if line.strip()]
		    # group by line number
		    for key, group in groupby(lines, lambda x: x.split()[1]):
		        interface = []
		        for thing in group:
		            # append lines without repeating part
		            interface += thing.split()[2:]
		        if interface:
					dev = str(key).rstrip(':')
					interfaces[dev] = interface	
			
		    for key in interfaces:
				bridge_member = ''
				try:
					for item in bridge_list:
						if key in bridges[item]:
							bridge_member = item
				except:
					pass
					
				try:
					index = interfaces[key].index('mtu')
					mtu = interfaces[key][index+1]
				except:
					mtu = ''
				try:
					index = interfaces[key].index('master')
					slaveof = interfaces[key][index+1]
				except:
					slaveof = ''
				try:
					index = interfaces[key].index('inet')
					ipaddr = interfaces[key][index+1]
				except:
					ipaddr = ''
				int_info[key].append([ipaddr, slaveof, mtu])
				try:
					index = interfaces[key].index('link/ether')
					hwaddr = interfaces[key][index+1]
				except:
					hwaddr = ''
				
				slaves = list()
				slaves.append(slaveof)
				slaves.append(bridge_member)
				int_info[key] = ([ipaddr, slaves, mtu, hwaddr])
	
	else:
		ipfile = False
	print colors.SECTION + colors.BOLD + 'IP ' + colors.ENDC
	if not brfile:
		print colors.RED + colors.BOLD + '\t BRIDGE INFORMATION NOT FOUND' + colors.ENDC
		print''
		
	if 	ipfile:

		print colors.WHITE + colors.BOLD + '\t {:^15}        {:^20}      {:^11}   {:^12} {:^24}'.format('INT','IP ADDR', 'MEMBER OF','MTU', ' HW ADDR')
		print '\t' + '=' * 16 + ' ' * 6 + '=' * 23 + ' ' * 4 + '=' * 13 + ' ' * 5 + '=' * 5 + '\t' + '=' * 19 + colors.ENDC
	
	else:
		print colors.RED + colors.BOLD + '\t NO IP ADDR FILE FOUND. CANNOT PARSE' + colors.ENDC
			

	for key in sorted(int_info):
		slavelist = ''
		value = int_info[key]
		key = str(key).rstrip(':')
		for item in value[1]:
			slavelist = slavelist + item
		if 'eth' in key or 'em' in key:
			linecolor = colors.BLUE
		elif 'vlan' in key:
			linecolor = colors.CYAN
		elif 'bond' in key:
			linecolor = colors.GREEN
		elif 'vnet' in key:
			linecolor = colors.WHITE
		else:
			linecolor = colors.PURPLE
		print '\t' + linecolor + '{:<15s}'.format(key) + '{:^36s}{:<16s}{:<5} \t {:<5}'.format(value[0],slavelist,value[2],value[3]) + colors.ENDC
	
	try:
		os.remove(temp_file.name)
		os.remove(mem_file.name)
	except:
		pass
			
			
def get_netdev_info(target):
	dev_info = {}
	with open(target +'proc/net/dev', 'r') as devfile:
		for line in devfile:
			if 'Inter' not in line:
				if ' face' not in line:
					index = line.find(':')
					key = line[0:index]
					dev_info[key] = line[index+1:len(line)].lstrip(' ').rstrip('\n')
					
		
	print colors.SECTION + colors.BOLD + 'Netdev' + colors.ENDC
	tab = '    '
	print colors.WHITE + colors.BOLD + '\t' + 'Interface' + tab + 'RxGBytes' + tab + 'RxPackets'	+ tab + 'RxErrs'\
	 + tab + 'RxDrop' + tab + 'TxGBytes' + tab + 'TxPackets' + tab + 'TxErrs' + tab + 'TxDrop'\
	 + tab + 'TxOvers' + colors.ENDC
	spacer = '  ' + '=' * 10 + '  '
	print colors.WHITE + tab + '   ' + '=' * 11 + spacer + '=' * 11 + '  ' + '=' * 8 + '  '\
	+ '=' * 8 + spacer + '=' * 11 + '  ' + '=' * 8 + '  ' + '=' * 8 + '  ' + '=' * 9 + colors.ENDC
	for item in sorted(dev_info):
		value = dev_info[item].split()
		for num in 0, 1, 4, 5:
			if value[num] == '':
				value[num] = 1
		if 'eth' in item or 'em' in item:
			linecolor = colors.BLUE
		elif 'vlan' in item:
			linecolor = colors.CYAN
		elif 'bond' in item:
			linecolor = colors.GREEN
		elif 'vnet' in item:
			linecolor = colors.WHITE
		else:
			linecolor = colors.PURPLE
		print linecolor + '\t' + '{:<10}'.format(item) + tab + '%6.2f' % round(int(value[0]) / (1024 * 1024 * 1024), 2)\
		+ tab + ' %7.0f' % round((int(value[1]) / (1000000)), 2) + ' m' + tab + '{:>4}'.format(value[2])\
		+ tab + '{:>6}'.format(value[3]) + tab + '%7.2f' % round(int(value[8]) / (1024 * 1024 * 1024), 2)\
		+ tab + '  %7.0f' % round((int(value[9]) / (1000000 )), 2) + ' m' + tab + '{:>4}'.format(value[10])\
		+ tab + '{:>6}'.format(value[11]) + tab + '{:>6}'.format(value[12]) + colors.ENDC
			
					
def get_bonding_info(target):
	bond_devs = {}
	for root, dirs, files in os.walk(target + 'proc/net/bonding'):
		for name in files:
			phys_devs = []
			hw_addrs = []
			with open(target + 'proc/net/bonding/' + name, 'r') as bfile:
				for line in bfile:
					index= line.find(':')
					if 'Bonding Mode:' in line:
						if '(round-robin)' in line:
							bond_mode = '0 (balance-rr)'
						elif '(active-backup)' in line:
							bond_mode = '1 (active backup)'
						elif '(xor)' in line:
							bond_mode = '2 (balance-xor)'
						elif '(broadcast)' in line:
							bond_mode = '3 (broadcast)'
						elif 'IEEE 802.3ad Dynamic link aggregation' in line:
							bond_mode = '4 (802.3ad - LACP)'
						elif 'transmit load balancing' in line:
							bond_mode = '5 (tlb)'
						elif 'adaptive load balancing' in line:
							bond_mode = '6 (alb)'
						else:
							bond_mode = line[index+1:len(line)]
					if 'Currently Active Slave' in line:
						active_dev = line[index+1:len(line)].rstrip('\n').lstrip(' ')
					if 'Slave Interface:' in line:
						dev = str(line[index+1:len(line)].rstrip('\n').lstrip(' '))
						try:
							if dev == active_dev:
								dev = dev + "*"
						except:
							pass
						phys_devs.append(dev)
						
					if 'Permanent HW addr' in line:
						hw_addrs.append(str(line[index+1:len(line)].rstrip('\n')))
					if os.path.isfile(target + 'etc/sysconfig/network-scripts/ifcfg-' + name):
						with open(target + 'etc/sysconfig/network-scripts/ifcfg-' + name, 'r') as bondfile:
							for line in bondfile:
								if 'BONDING_OPTS' in line or 'bonding_opts' in line:
									index = line.find('=')
									bond_opts = line[index+1:len(line)].lstrip("'").rstrip('\n')
									bond_opts = bond_opts.rstrip("'")
				try:
					bond_opts
				except:
					bond_opts = ''
				if not phys_devs:
					phys_devs.append(' [None]')
				if not hw_addrs:
					hw_addrs.append('')
				bond_devs[name] = (bond_mode, bond_opts, phys_devs, hw_addrs)
			
	print colors.SECTION + colors.BOLD + 'Bonding' + colors.ENDC
	print colors.WHITE + colors.BOLD + '\t {:^10}    {:^20}   {:^30}   {:^34}'.format('Device', 'Mode', 'BONDING OPTS', 'Slave Interfaces')
	print '\t ' + '=' * 10 + '\t' + '=' * 19 + '\t  ' + '=' * 21 + '\t\t   ' + '=' * 26 + colors.ENDC
	for item in sorted(bond_devs):
		value = bond_devs[item]
		print colors.GREEN + '\t {:<10}'.format(item) + colors.ENDC + '     {:^20}'.format(value[0]) + '\t  {:<26}'.format(value[1]) + '{:>14} {:<18}'.format(value[2][0], value[3][0])
		dev_count = 1
		for each in value[2]:
			try: 
				if value[2][dev_count]:
					print '  {:>87}{:>20}'.format(value[2][dev_count], value[3][dev_count])
					dev_count += 1
			except:
				print colors.PURPLE + '\t' * 10 + '   ' + '- ' * 10 + colors.ENDC


def get_ethtool_info(target):
	# get list of all devices
	dev_list = []
	dev_info = {}
	with open(target +'proc/net/dev', 'r') as devfile:
		for line in devfile:
			if 'Inter' not in line:
				if ' face' not in line:
					index = line.find(':')
					dev = str(line[0:index]).strip()
					if 'lo' not in dev:
						dev_list.append(dev)
						
	# for each device found, get ethtool reported info
	for device in dev_list:
		link_state, link_speed, an_state = get_full_eth(target, device)
		driver, drv_ver, firmware_ver = get_ethi_info(target, device)
		rxring, rxjumbo = get_ring_info(target, device)
		dev_info[device] = [link_state, link_speed, an_state, rxring, rxjumbo, driver, drv_ver, firmware_ver]
	print colors.SECTION + colors.BOLD +  'Ethtool' + colors.ENDC
	print colors.WHITE + colors.BOLD + '\t {:^10}    {:^20}  {:^8}  {:^15}   {:^15}'.format('Device', 'Link', 'Auto-Neg', 'Ring', 'Driver Info')
	print '\t ' + '=' * 10 + '\t ' + '=' * 17 + '  ' + '=' * 10 + '\t ' + '=' * 10 + '\t ' + '=' * 15 + colors.ENDC
	for item in sorted(dev_info):
		if ';' not in item:
			value = dev_info[item]
			if 'bond' in item:
				linecolor = colors.GREEN
			elif 'eth' in item or 'em' in item:
				linecolor = colors.BLUE
			else:
				linecolor = colors.PURPLE
			print '\t' + linecolor + item + '\t\t ' + '{:<8}'.format(value[0]) + '{:<9}'.format(value[1]) + '   {:3}'.format(value[2]) + '\t  %4s%3s' %(value[3], value[4]) + '\t  ' + '{:<8}'.format(value[5]) + ' ver: {:5}  fw: {:8}'.format(value[6], value[7])

def get_ring_info(target, device):
	rx = ''
	rxjumbo = ''
	if os.path.isfile(target + 'sos_commands/networking/ethtool_-g_' + device):
		with open(target + 'sos_commands/networking/ethtool_-g_' + device, 'r') as efile:
			for line in efile:
				if 'RX:' in line:
					rx = line.split()[1]
				if 'RX Jumbo:' in line:
					rxjumbo = line.split()[2]
	return rx, rxjumbo
			
def get_full_eth(target, device):
	link_speed = ''
	an_state = 'off'
	link_state = ''
	if os.path.isfile(target +  'sos_commands/networking/ethtool_' + device):
		with open(target + 'sos_commands/networking/ethtool_' + device, 'r') as efile:
			for line in efile:
				if 'Link detected: no' in line:
					link_state = 'UNKNOWN'
				if 'Link detected: yes' in line:
					link_state = 'UP'
				if 'Speed:' in line:
					link_speed = line.split()[1]
				if 'Auto-negotiation:' in line:
					an_state = line.split()[1]
	return link_state, link_speed, an_state
	
					
def get_ethi_info(target, device):
	driver = ''
	drv_ver = ''
	firmware_ver = 'unknown'
	if os.path.isfile(target +  'sos_commands/networking/ethtool_-i_' + device):
		with open(target + 'sos_commands/networking/ethtool_-i_' + device, 'r') as efile:
			for line in efile:
				if 'driver:' in line:
					driver = line.split()[1]
					driver = driver.strip()
				if re.match('^version:', line):

					try: 
						drv_ver = line.split()[1]
					except:
						drv_ver = ''
				if 'firmware-version:' in line:
					try:
						firmware_ver = line.split()[1]
					except:
						firmware_ver = 'unknown'
	return driver, drv_ver, firmware_ver							


def get_storage_info(target, local):
	disks = defaultdict(list)
	total_space = 0
	num_disks = 0

	disk_file = target + 'proc/partitions'
		
	with open(disk_file, 'r') as dfile:
		for line in dfile:
			if 'emc' not in line:
				if re.match('^ \d*', line):
					dev = str(line.split()[3]).strip()
					# check if dev ends in a number, meaning this would be a partition 
					if not re.search(r'\d+$', dev):	
						disks[dev] = round(((int(line.split()[2])) / 1048576), 0)
						total_space += round(((int(line.split()[2])) / 1048576), 0)
						num_disks += 1
						
					else:
						# cciss devices would all get called partitions in the above. Here we handle them explicitly
						if 'cciss' in dev:
							# cciss partitions format as cxdxpx
							if 'p' in dev:
								pass
							else:
								disks[dev] = round(((int(line.split()[2])) / 1048576), 0)
								total_space += round(((int(line.split()[2])) / 1048576), 0)
								num_disks += 1
	
						else:
							pass
		
	
	print colors.SECTION + colors.BOLD + 'Storage' + colors.ENDC
	print colors.HEADER_BOLD + '\t Whole disks on system :  ' + colors.ENDC + str(num_disks)
	print colors.GREEN + '\t Total amount of storage on system : ' + colors.ENDC + str(total_space) + ' GB' + '  ( %2.2f TB)' %((total_space / 1024))
	print colors.WHITE + '\t {:^25}  {:^10}'.format('Disk', 'Size in GB') 
	print '\t\t' + '=' * 11 + '\t ' + '=' * 15 + colors.ENDC
	for item in sorted(disks):
		print '\t\t{:14}  {:>15}'.format(item, disks[item])
			
					
def get_rhev_info(target, check_db):
	# logic to determine hyp/manager
	rhevm = find_rpm(target, 'rhevm')
	if 'not' in rhevm:
		manager = False
	else:
		manager = True
	if manager:
		get_rhevm_info(target, check_db)
	else:
		get_rhev_hyp_info(target)

def get_rhev_hyp_info(target):
		packages = {}
		rpm_check = {}
		vm_list = []
		running_vms = 0
		warn_count = 0
		rhevh_release = get_status(target, 'release')
		if 'Hypervisor' in rhevh_release:
			hyper_ver = rhevh_release[rhevh_release.find('('):rhevh_release.find('.el6)')]
		packages['kernel'] = find_rpm(target, 'kernel')
		# Find package versions
		packages['vdsm'] = find_rpm(target, 'vdsm')
		packages['libvirt'] = find_rpm(target, 'libvirt')
		packages['spice'] = find_rpm(target, 'spice-server')
		packages['qemu_img'] = find_rpm(target, 'qemu-img-')
		packages['qemu_kvm'] = find_rpm(target, 'qemu-kvm-')
		packages['qemu_tools'] = find_rpm(target, 'qemu-kvm-rhev-tools')
		# Check RPM versions. Has to be a better way to do this
		rpm_check['kernel'] = check_rpm_ver(packages['kernel'])
		rpm_check['vdsm'] = check_rpm_ver(packages['vdsm'])
		rpm_check['libvirt'] = check_rpm_ver(packages['libvirt'])
		rpm_check['spice'] = check_rpm_ver(packages['spice'])
		rpm_check['qemu_img'] = check_rpm_ver(packages['qemu_img'])
		rpm_check['qemu_kvm'] = check_rpm_ver(packages['qemu_kvm'])
		rpm_check['qemu_tool'] = check_rpm_ver(packages['qemu_tools'])
		
		for item in rpm_check:
			if rpm_check[item]:
				warn_count += 1
				
		for item in packages:
			if 'not installed' in packages[item]:
				packages[item] = 'Not Installed'
			else:
				index = str(packages[item]).find('.')
				index2 = str(packages[item]).find('.el')
				packages[item] = str(packages[item])[index-1:index2]

		
		
		# get number of VMs running on this hypervisor currently
		if os.path.isfile(target + 'ps'):
			with open(target + 'ps', 'r') as psfile:
				for line in psfile:
					if '/usr/libexec/qemu-kvm ' in line:
						running_vms += 1
						index = line.find('-name')
						index2 = line.find("-S -M")
						vm_list.append(str(line[index+6:index2]).strip())
		
		print colors.SECTION + 'Virtualization'
		print colors.HEADER_BOLD + '\t Release    : ' + colors.ENDC + rhevh_release
		print colors.HEADER_BOLD + '\t Kernel     : ' + colors.ENDC + packages['kernel']
		print ''
		print colors.HEADER_BOLD + '\t vdsm       : ' + colors.ENDC + packages['vdsm'] + '\t' + \
		colors.HEADER_BOLD + '\t libvirt    : ' + colors.ENDC + packages['libvirt']
		print colors.HEADER_BOLD + '\t SPICE      : ' + colors.ENDC + packages['spice'] + '\t\t' + \
		colors.HEADER_BOLD + '\t RHEV tools : ' + colors.ENDC + packages['qemu_tools']
		print colors.HEADER_BOLD + '\t qemu-img   : ' + colors.ENDC + packages['qemu_img']+ '\t' + \
		colors.HEADER_BOLD + '\t qemu-kvm   : ' + colors.ENDC + packages['qemu_kvm']
		print '\n'

		if warn_count > 0:
			print colors.RED + colors.BOLD + '\t WARNING : ' + colors.ENDC 
			for item in rpm_check:
				if rpm_check[item]:
					print '\t\t {:10} {:10}: {:<30} '.format(item, packages[item], str(rpm_check[item][0]).rstrip('\n'))
					print '\t\t\t KCS : ' + colors.WHITE + '{} '.format(rpm_check[item][1]) + colors.ENDC + '\tBZ : ' + colors.WHITE + \
					'{}'.format(rpm_check[item][2]) + colors.ENDC
		
		print ''			
		print colors.HEADER_BOLD + '\t Running VMs on this host : ' +colors.ENDC + str(running_vms)
		vm_list.sort()
		rows = math.ceil(len(vm_list) / 5)
		for number in range(0, int(rows)):
			to_print = []
			for i in range(0, 5):
				try:
					to_print.append(vm_list[4-i])
					
					vm_list.remove(vm_list[4-i])
				except:
					to_print.append('')
						
			print colors.GREEN + '\t\t' + '{:15} {:15} {:15} {:15} {:15}'.format(to_print[4][:15], to_print[3][:15], to_print[2][:15], to_print[1][:15], to_print[0][:15]) + colors.ENDC	
	


def get_rhevm_info(target, check_db):
	# grab / print basic information first
	print colors.SECTION + colors.BOLD + "RHEV-M Information"
	print '\n'

	# Find RHEVM rpm
	rhevm_ver = find_rpm(target, "rhevm-3")
	print colors.HEADER_BOLD + "\t Version: " + colors.CYAN+ rhevm_ver + colors.ENDC
	
	rhevm_check = check_rpm_ver(rhevm_ver)

	if rhevm_check:
		print colors.RED + colors.BOLD + '\n\t WARNING : ' + colors.ENDC + '{} : {}'.format(rhevm_ver[0:(rhevm_ver.find('.el'))],rhevm_check)
	
	# Find simplified version for debug purposes
	if "-3.0" in rhevm_ver:
		simpleVer = "3.0"
	elif "-3.1" in rhevm_ver:
		simpleVer = "3.1"
	elif "-3.2" in rhevm_ver:
		simpleVer = "3.2"
	else:
		simpleVer = "Could not be found" 
	
	# Try to find database
	database = False
	fullPath = os.path.abspath(target)
	
	lcRoot = os.path.dirname(fullPath)
	
	if os.path.isdir(lcRoot + "/database"):
		database = True
		dbDir = lcRoot + "/database"
		
	# The following is only possible if we found the db above
	if database:
		print colors.HEADER_BOLD + "\t Database: " + colors.ENDC +"Found. Can give database overview with --db"

		# Find errors first
		parse_manager_logs(target)

		if check_db:	
			
			# Compensate for 3.0 / 3.x database differences
			if simpleVer == "3.1" or simpleVer == "3.2":
				# Eval manager before moving on to db analysis
				rhev_eval_db(dbDir)
			elif simpleVer == "3.0":
				print colors.WARN + "\t Not ready to parse 3.0 databases yet, may not be trustworthy!!" + colors.ENDC
			else:
				print colors.WARN + "\t Database version could not be found without RPM information." + colors.ENDC
				rhev_eval_db(dbDir)
		else:
			pass	
		
	else:
		print colors.WARN + "Database not found" + colors.ENDC
		
		# Find errors first
		parse_manager_logs(target)
	
	
# Method for evaluating the database for env information
# This method should expect to be passed the directory containing the database
def rhev_eval_db(dbDir):
	
	
	if os.path.exists(dbDir + "/sos_pgdump.tar"):
		dbTar = dbDir + "/sos_pgdump.tar"
		
		
		masterDB = Database(dbTar)
		
		# create DC list
		dc_list = masterDB.get_data_centers()
		
		print ""
		print colors.SECTION + colors.BOLD + "RHEV Database Information" + colors.ENDC
		print ""
		
		print '\n\t' + colors.BOLD + colors.GREEN + '[Data Centers Managed By RHEV-M]' + colors.ENDC 
		dc_table = Table(dc_list,"name","uuid","compat")
		dc_table.display()
		
				
		####### End of Data Center Parsing #######
		
		print '\n\t' + colors.BOLD + colors.GREEN + '[Storage Domains In All Data Centers]' + colors.ENDC
		sd_list = masterDB.get_storage_domains()
		sd_table = Table(sd_list,"name","uuid","storage_type","master")
		sd_table.display()
		


	####### End of Storage Domain Parsing ######
		
		# Generating clusters for host reference
		cluster_list = masterDB.get_clusters()
		
		host_list = masterDB.get_hosts()

		hostDirs = []
		hostNameLen = 5
		# look for all files in the parent of the passed 'dbDir', and if it is a dir then attempts to parse
		rootDir = os.path.dirname(dbDir)
		
		for d in os.listdir(rootDir):
			
			if os.path.isdir(rootDir+"/"+d):
				hostDirs.append(d)
				
		
		
		for h in host_list:
			for d in dc_list:
				if h.get_uuid() == d.get_spm_uuid():
					h.set_spm_status(True)
				else:
					h.set_spm_status(False)

			for c in cluster_list:
				if c.get_uuid() == h.get_host_dc_uuid():
					
					for d in dc_list:
						
						if c.get_dc_uuid() == d.get_uuid():
							h.set_host_dc_name(d.get_name())
							
					
			# try and find release version
			hostDirName = h.get_name().split(".")
		
			for dir in hostDirs:
				
				names = dir.split("-")

				if names[0] == hostDirName[0]:
				
					# this is a stupid hack, using '..' in the path name. stop being lazy and find a better alternative
					releaseFile = open(dbDir+"/../"+dir+"/etc/redhat-release")
					releaseVer = releaseFile.readlines()
					if "Hypervisor" in releaseVer[0]:
						host_release = releaseVer[0].split("(")[1]
						# strip the newline character at the end of the line
						host_release = host_release.replace("\n","")
						host_release = host_release.rstrip(")")
						h.set_release_ver(host_release)
					else:
						host_release = releaseVer[0].split()[6]
						h.set_release_ver(host_release)
		

		print '\n\t' + colors.BOLD + colors.GREEN + '[Hypervisors In All Data Centers]' + colors.ENDC
		host_table = Table(host_list,"name","uuid","host_dc_name","host_type", "release_ver", "spm_status")
		host_table.display()
		
		
	else:
		print colors.WARN + "Could not find a database file"
		
# Finds relevant files after dbdump has been extracted
def findDat(table,restFile):
	'''
	Subroutine to find the dat file name in restore.sql
	''' 
	openFile = open(restFile, "r")
	lines = openFile.readlines()
	

	
	for n in lines:
		if n.find(table) != -1:
			if n.find("dat") != -1:
				datInd = n.find("PATH")
				datFileName =  n[datInd+7:datInd+15]
				if datFileName.endswith("dat"):
				
					return datFileName
	
def parse_manager_logs(target):
	'''
	The plan here is to grab the most recent errors from engine.log/rhevm.log, messages, server.log(maybe) and present them in a readable fashion
	
	Passing the parsing duties (heh, duties) to functions to keep things relatively modular
	'''
		
	# grab / print basic information first
	print ""
	print colors.SECTION + colors.BOLD + "Log Files"
	print ""
	
	# Gather main log files
	try:
		#print colors.WARN + "\t " + target + "/var/log/ovirt-engine/engine.log"
		engine_log = open(target+"var/log/ovirt-engine/engine.log")
		print colors.WHITE + '\t [engine.log error parsing]' + colors.ENDC
		parse_engine_log(engine_log)
	except IOError:
		print colors.WARN + "\t Could not open the engine.log file" + colors.ENDC
	
	### Holding off on implementing  this for the manager, as we do not often see useful information here
# 	try:
# 		messages_log = open(target+"var/log/messages")
# 		print colors.PURPLE + "\t /var/log/messages: " + colors.GREEN + "loaded"
# 		parse_messages_log(messages_log)
# 	except IOError:
# 		print colors.WARN + "\t Could not open /var/log/messages file"
		
def parse_engine_log(logFile):
	'''
	Goal: Find the most recent error line with verbose information, split it up, and present it
	'''
	
	# Find most recent error line
	lines = logFile.readlines()
	errorLines = []
	for line in lines:
		if "ERROR" in line:

			errorLines.append(line)
	print ''
	
	for x in range(1,4):
		lastLine = len(errorLines)-x
		errorLine = errorLines[lastLine]
		errorProperties = errorLine.split(" ")
		'''
		0 - Date
		1 - Time
		3 - Command run
		7+ - Message
		'''
		
		print colors.HEADER_BOLD + "\t Time Stamp: " + colors.ENDC + errorProperties[0] + " " + errorProperties[1]	
		print colors.HEADER_BOLD + "\t Command: " + colors.ENDC + errorProperties[3].lstrip("[").rstrip("]")
		
		# Trying to hack this since messages seem to vary in length - basing on last capital letter. deal with it
		errMessParts =  errorProperties[7:]
		errorMessage = ""
		for p in errMessParts:
			#print p
			for c in p:
				if c in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
					#print errMessParts.index(p)
					index = errMessParts.index(p)
					errorMessage = ' '.join(errMessParts[index:]).replace("\n","")
					#print errorMessage
			
		print colors.HEADER_BOLD + "\t Message: " + colors.ENDC  + errorMessage
	
		singleOccurance = True
		occurances = 0
		for line in lines:
			if ' '.join(errorProperties[7:]) in line:
				occurances += 1
		if occurances > 1:
			singleOccurance = False
		
		if singleOccurance:
			print colors.HEADER_BOLD + "\t Only occurance of this error: " + colors.WHITE + "Yes"
		else:
			print colors.HEADER_BOLD + "\t Only occurance of this error: " + colors.ENDC + colors.RED + "No. Errors appear " + str(occurances) + " times in engine.log starting at " + ' '.join(errorLines[0].split(" ")[0:2]) + colors.ENDC
			
		print ""

def parse_messages_log(logFile):
	print ""

def get_ps_info(target):
	print colors.HEADER_BOLD + 'PS' + colors.ENDC
	retval = parse_ps_file(target)	
	usage = defaultdict(list)
	bad_proc = defaultdict(list)
	bad_procs = 0 
	header = '\t' + colors.BLUE + colors.BOLD + '{:^6}\t{:^6}\t{:^5} {:^5}  {:^7}  {:^7}  {:^4} {:^4}  {:^5}{:^8} {:<8}'.format('USER', 'PID', '%CPU', \
	'%MEM', 'VSZ-MB', 'RSS-MB', 'TTY', 'STAT', 'START', 'TIME', 'COMMAND') + colors.ENDC
	print '\t' + colors.WHITE + 'Total processes : ' + colors.ENDC + str(len(retval)) +'\n'
	# get top usage by user
	for item in retval:
		value = retval[retval.index(item)]
		if usage.has_key(value[0]):
			usage[value[0]][0] += float(value[2])
			usage[value[0]][1] += float(value[3])
			usage[value[0]][2] += float(value[5])
		else:
			usage[value[0]] = [float(value[2]), float(value[3]), float(value[5])]
	
	print '\t' + colors.WHITE + 'Top Users of CPU and MEM : ' + colors.ENDC
	print '\t ' + colors.BLUE + colors.BOLD + '{:6}  {:5}  {:5}  {:7}'.format('USER', '%CPU', '%MEM', 'RSS') + colors.ENDC
	report_usage = sorted(usage.items(), reverse=True, key=lambda x: x[1][2])
	for i in xrange(0,4):
		value = report_usage[i]
		print '\t {:<7}  {:<5} {:^5}  {:<5.2f} GB'.format(value[0], value[1][0], value[1][1], int(value[1][2]) / 1048576)
	print ''
	# search for defunct and trouble processes
	for item in retval:
		value = retval[retval.index(item)]
		if any('<defunct>' in item for item in value) or any('D' in item for item in value[7]):
			bad_procs += 1
			bad_proc[bad_procs] = value
	if bad_procs > 0:
		print '\t' + colors.WHITE + 'Uninterruptable Sleep and Defunct Processes : ' + colors.ENDC
		print header
		for each in range(bad_procs):
			print_ps_info(bad_proc[bad_procs], 1, single=True)
	
	# sort by CPU usage	
	print '\t' + colors.WHITE + 'Top CPU processes : ' + colors.ENDC
	print header
	retval.sort(reverse=True, key=lambda x: float(x[2]))
	print_ps_info(retval, 5)
	
	# sort by MEM usage
	# Known bug: if retval is not refreshed, sorting by memory breaks. I have no idea why
	print '\t' + colors.WHITE + 'Top Memory processes : ' + colors.ENDC
	print header
	retval = parse_ps_file(target)
	retval.sort(reverse=True, key=lambda x: float(x[5]))	
	print_ps_info(retval, 5)	

def parse_ps_file(target):
	retval = []
	with open(target + 'ps', 'r') as psfile:
		psfile.next()
		for line in psfile:
			proc = line.split()
			nfields = len(line.split()) -1
			retval.append(line.split(None, nfields))
	return retval

def print_ps_info(retval, num, single=False):
	for i in xrange(0,num):
		if single:
			ps = retval
		else:
			ps = retval[i]
		ps[4] = int(ps[4]) / 1024
		ps[5] = int(ps[5]) / 1024
		cmd = ''
		for i in xrange(10, 13):
			try:
				cmd = cmd + ' ' + str(ps[i]).strip('\n')
			except:
				pass
		print '\t{:^7}\t{:^6}\t{:^5} {:^5}  {:<7.0f}  {:<7.0f}  {:^5} {:^4} {:^6} {:<7}{}'.format(ps[0], ps[1], ps[2], ps[3], ps[4], ps[5], ps[6], ps[7], ps[8], ps[9], cmd[0:50])
	print ''


def get_main(runall, os, mem, kdump, cpu, sysctl, ip, bonding, test, netdev, rhev, db, eth, net, bios, lspci,\
 disk, ps, check, local, target):
	if runall:
		os = True
		mem = True
		kdump = True
		cpu = True
		sysctl = True
		ip = True
		bonding = True
		netdev = True
		eth = True
		bios = True
		disk = True
	if net:
		ip = True
		bonding = True
		eth = True
		netdev = True
	if os:
		get_os_info(target, local)
	if mem:
		get_mem_info(target)
	if bios:
		get_bios_info(target, local)
	if kdump:
		get_kernel_info(target, local)
	if cpu:
		get_cpu_info(target)
	if sysctl:
		get_sysctl_info(target)
	if ip:
		get_ip_info(target, local)
	if bonding:
		get_bonding_info(target)
	if eth:
		get_ethtool_info(target)
	if netdev:
		get_netdev_info(target)
	if lspci:
		get_lspci_info(target, local)
	if rhev:
		get_rhev_info(target, db)
	if disk:
		get_storage_info(target, local)
	if ps:
		get_ps_info(target)
	if check:
		check_installed(target, check)
		
				
			
			
target = args.target[0]
if target == '/':
	local = True
else:
	local = False
if not target.endswith('/'):
	target = target + '/'
	

get_main(args.all, args.os, args.memory, args.kdump, args.cpu, args.sysctl, args.ip\
, args.bonding, args.test, args.netdev, args.rhev, args.db, args.ethtool, args.net, args.bios, args.lspci, args.disk, args.ps, args.check, local, target)




